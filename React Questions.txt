ğŸŸ  SECTION 5: Forms & User Input (REAL PROJECT SCENARIOS)

Controlled form with multiple inputs (single state object)

Disable submit until form is valid

Show validation error messages

Real-time validation

On-blur validation

Controlled checkbox group

Select all / deselect all checkboxes

Controlled radio buttons

Multi-select dropdown

Dynamic form fields (add / remove rows)

Form reset logic

File upload using useRef

Large form performance issue

Optimize large form rendering

Multi-step form

Character counter

OTP input (4 / 6 digit)

Resend OTP with throttle

Search input with debounce

Password strength checker

Dependent dropdowns

Prevent double form submit

Form submission lifecycle



ğŸŸ¤ SECTION 7: Custom Hooks (SENIOR EXPECTATION)


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


1. Build useLocalStorage.

2. Build useFetch.

3. Hook for form logic.

4. Hook for pagination.

5. Hook for window resize.

6. Hook for keyboard events.

7. Hook for outside click detection.

8. Hooks + Context Pattern

9. Why do we store callbacks in refs in some hooks?

10. Supporting SSR / safe browser APIs

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>






ğŸŸ¤ SECTION 8: Component Design Patterns 


1. Controlled vs uncontrolled components

2. Compound components pattern

3. Build Tabs using compound pattern

4. Build Accordion using compound pattern

5. Render props pattern

6. HOC pattern

7. Hooks vs HOC

8. Context API usage

9. Context performance optimization

10. Build reusable modal

11. Close modal on outside click

12. Portal usage

13. Slot-based components

14. Composition vs inheritance

15. Dumb vs smart components

16. Container-presentational pattern

17. Reusable button component

18. Feature-based folder structure

19. Component API design

20. Error boundary implementation










ğŸ”· SECTION 9: Modern React (React 18 / 19 Awareness)

Automatic batching

Concurrent rendering basics

useTransition

useDeferredValue

Suspense basics

Suspense for data fetching (concept)

Server Components (concept)

Client vs server components

Streaming rendering (concept)

When concurrency helps

When concurrency hurts

Priority updates

Blocking vs non-blocking updates

Progressive rendering



âš« SECTION 10: Debugging & Tricky Scenarios (REAL INTERVIEWS)

Fix infinite re-render bug

Fix stale state bug

Fix broken dependency array

Fix memory leak

Fix event handler bug

Fix wrong closure issue

Fix incorrect key usage

Fix form lag issue

Fix unnecessary API calls

Fix modal scroll bug

Fix double API submit

Fix flickering UI issue

Fix incorrect conditional render

Fix race condition in fetch

Fix debounce bug





ğŸ FINAL BOSS â€” MOCK INTERVIEW TASKS

Build debounced search + explain flow

Build todo app with filters

Build reusable modal (no library)

Optimize re-render-heavy component

Design form architecture

Fix performance bottleneck

Explain render cycle verbally

Explain hooks execution order

Explain cleanup execution timing

# Number of questions 

ğŸŸ¢ Section 1 (Fundamentals): 16

ğŸŸ¡ Section 2 (State/Immutability/Lists): 19

ğŸ”µ Section 3 (useEffect): 18

ğŸŸ£ Section 4 (Debounce/Throttle): 6

ğŸŸ  Section 5 (Forms): 23

ğŸ”´ Section 6 (Re-renders/Perf): 20

ğŸŸ¤ Section 7 (Custom Hooks): 20


ğŸŸ¤ Section 8 (Design Patterns): 20

ğŸ”· Section 9 (Modern React): 14

âš« Section 10 (Debugging): 15

ğŸ Final Boss (Mock tasks): 9

âœ… Total = 180

=====================================================================================================================

Missing / under-covered areas (add these)
1) React Router (very common in real projects)

Build protected routes (AuthGuard)

Nested routes + Outlet

Dynamic routes (/users/:id) + params

Search params (filter/sort via URL)

Navigation: useNavigate, Link, back button handling

Lazy route loading + Suspense fallback

2) Data fetching patterns beyond basic useEffect

Request dedupe / caching (why React Query / SWR)

Retry + exponential backoff

Pagination: cursor-based (not just page numbers)

Race condition fix (latest request wins)

Optimistic UI update (add item instantly, rollback on failure)

3) State management (senior filter)

useReducer real use case (form/todo complexity)

Context vs Redux vs Zustand â€” when to use what

Avoid Context re-render (split contexts, selectors pattern)

Basic Redux Toolkit slice + async thunk (even if not deep)

4) Testing (many seniors get filtered here)

Test a component with React Testing Library

Test custom hook

Mock fetch / API

Test user flows (form submit, debounce search, modal open/close)

5) Accessibility (companies care)

Keyboard nav for modal (ESC close, focus trap concept)

Proper labels, aria attributes

Button vs div click handlers (semantic HTML)

Accessible error messages in forms

6) TypeScript with React (if role expects TS)

Type props correctly (optional, union, generics)

useRef typing

Event types (ChangeEvent, FormEvent)

React.FC discussion (pros/cons)

children typing patterns

7) Rendering & SSR basics (often asked)

SSR vs CSR vs hydration (concept)

Hydration mismatch causes (common bug)

Lazy loading components + code splitting (practical)

8) Component communication edge cases

forwardRef + useImperativeHandle (common in UI libraries)

Controlled vs uncontrolled with refs (focus, reset)

Error boundaries: you have it, but add fallback UI + reset pattern

9) Styling & UI architecture (real-world)

CSS Modules vs styled-components vs Tailwind (tradeoffs)

Theming (dark mode) via context

Design system component API (Button/Input variants)